###############################################################################
## This confidential and proprietary code may be used only as authorized
## by licensing agreement from Xylon d.o.o.
## In the event of publication, the following notice is applicable:
##
## Copyright 2011 - Xylon d.o.o.
## All rights reserved.
##
## The entire notice above must be reproduced on all authorized copies.
###############################################################################
###############################################################################
##
## Name     : logicvc
## Desc     : Microprocessor Peripheral Description
##
###############################################################################

BEGIN logicvc

## Peripheral Options
OPTION RUN_NGCBUILD = TRUE
OPTION IPTYPE = PERIPHERAL
OPTION IMP_NETLIST = TRUE
OPTION HDL = VHDL
OPTION USAGE_LEVEL = BASE_USER
OPTION IP_GROUP = logicBRICKS
OPTION ARCH_SUPPORT_MAP = (others=PRODUCTION)
OPTION DESC = Xylon Compact Video Controller
OPTION LONG_DESC = The logiCVC is Xylon Video controller. Please contact Xylon for further details.
OPTION TCL_FILE = logicvc_v2_1_0.tcl
OPTION IPLEVEL_DRC_PROC = check_iplevel_settings
## OPTION SIM_MODELS = BEHAVIORAL

## Bus Interfaces
BUS_INTERFACE BUS = MPLB, BUS_STD = PLBV46, BUS_TYPE = MASTER, GENERATE_BURSTS = TRUE, EXCLUDE_BUSIF = (XMB || M_AXI), ISVALID = (C_VMEM_INTERFACE == 0)
BUS_INTERFACE BUS = XMB, BUS_TYPE = INITIATOR, BUS_STD = XMB, EXCLUDE_BUSIF = (MPLB || M_AXI), ISVALID = (C_VMEM_INTERFACE == 1)
BUS_INTERFACE BUS = M_AXI, BUS_STD = AXI, BUS_TYPE = MASTER, EXCLUDE_BUSIF = (MPLB || XMB), ISVALID = (C_VMEM_INTERFACE == 2)
BUS_INTERFACE BUS = SOPB, BUS_STD = OPB, BUS_TYPE = SLAVE, EXCLUDE_BUSIF = (SPLB || S_AXI), ISVALID = (C_REGS_INTERFACE == 0)
BUS_INTERFACE BUS = SPLB, BUS_STD = PLBV46, BUS_TYPE = SLAVE, EXCLUDE_BUSIF = (SOPB || S_AXI), ISVALID = (C_REGS_INTERFACE == 1)
BUS_INTERFACE BUS = S_AXI, BUS_STD = AXI, BUS_TYPE = SLAVE, EXCLUDE_BUSIF = (SPLB || SOPB), ISVALID = (C_REGS_INTERFACE == 2)


## Generics for VHDL or Parameters for Verilog
PARAMETER C_IP_LICENSE_TYPE = 1, DT = INTEGER, RANGE = (0:3), VALUES = (0=source,1=evaluation,2=release,3=university evaluation), ISVALID = (0==1)
PARAMETER C_IP_MAJOR_REVISION = 3, DT = INTEGER, RANGE = (0:31), ISVALID = (0==1)
PARAMETER C_IP_MINOR_REVISION = 00, DT = INTEGER, RANGE = (0:31), ISVALID = (0==1)
PARAMETER C_IP_PATCH_LEVEL = 0, DT = INTEGER, RANGE = (0:25), VALUES = (0=a,1=b,2=c,3=d,4=e,5=f,6=g,7=h,8=i,9=j,10=k,11=l,12=m,13=n,14=o,15=p,16=q,17=r,18=s,19=t,20=u,21=v,22=w,23=x,24=y,25=z), ISVALID = (0==1)
PARAMETER C_IP_LICENSE_CHECK = 0, DT = INTEGER, RANGE = (0,1), VALUES = (0=no,1=yes), ISVALID = (0==1)
PARAMETER C_IP_TIME_BEFORE_BREAK = 1, DT = INTEGER, RANGE = (0:3), VALUES = (0=infinite,1=1h,2=12h,3=24h), ISVALID = (0==1)
PARAMETER C_FAMILY = spartan3:spartan3e:spartan3a:virtex4:virtex5:virtex6:spartan6:kintex7:virtex7:artix7:zynq, DT = STRING
########## Video Memory ##########
PARAMETER C_VMEM_INTERFACE = 0, DT = INTEGER, RANGE = (0,1,2), VALUES = (0=PLBv46, 1=XMB, 2=AXI), DESC = "Use Xylon Memory Bus, PLB or AXI to access video memory"
PARAMETER C_VMEM_BASEADDR = 0xffffffff, DT = std_logic_vector, ADDRESS = BASE, PAIR = C_VMEM_HIGHADDR, ADDR_TYPE = MEMORY, ASSIGNMENT = REQUIRE, PERMIT = BASE_USER, DESC = Video Page Address #, BUS = MPLB:XMB:M_AXI
PARAMETER C_VMEM_HIGHADDR = 0x00000000, DT = std_logic_vector, ADDRESS = HIGH, PAIR = C_VMEM_BASEADDR, ADDR_TYPE = MEMORY, ASSIGNMENT = REQUIRE, PERMIT = BASE_USER, DESC = Video Page Size #, BUS = MPLB:XMB:M_AXI
PARAMETER C_MEM_BURST = 4, DT = INTEGER, RANGE = (4, 5, 6), VALUES = (4=16, 5=32, 6=64), ISVALID = (C_VMEM_INTERFACE == 1 || C_VMEM_INTERFACE == 2 || (C_VMEM_INTERFACE == 0 && (C_MPLB_DWIDTH == 64 || C_MPLB_DWIDTH == 128)))
PARAMETER C_MEM_BYTE_SWAP = 0, DT = INTEGER, RANGE = (0,1), DESC = "Memory access byte swap"
PARAMETER C_MEM_LITTLE_ENDIAN = 1, DT = INTEGER, RANGE = (0,1), VALUES = (0=Big endian,1=Little endian), ASSIGNMENT=OPTIONAL_UPDATE, IPLEVEL_UPDATE_VALUE_PROC = iplevel_update_endian
PARAMETER C_INCREASE_FIFO = 1, DT = INTEGER, RANGE = (1,2,4,8), VALUES = (1=Normal size, 2=x2, 4=x4, 8=x8), DESC = "FIFO size multiplication factor"
## PLB Master generics
PARAMETER C_MPLB_AWIDTH = 32, DT = INTEGER, BUS = MPLB, ISVALID = (C_VMEM_INTERFACE == 0)
PARAMETER C_MPLB_DWIDTH = 64, DT = INTEGER, RANGE = (32, 64, 128), BUS = MPLB, ISVALID = (C_VMEM_INTERFACE == 0)
PARAMETER C_MPLB_NUM_MASTERS = 8, DT = INTEGER, BUS = MPLB, ISVALID = (C_VMEM_INTERFACE == 0)
PARAMETER C_MPLB_SMALLEST_SLAVE = 32, BUS = MPLB, DT = INTEGER, ISVALID = (C_VMEM_INTERFACE == 0)
PARAMETER C_MPLB_NATIVE_DWIDTH = 32, DT = INTEGER, RANGE = (32, 64, 128), BUS = MPLB, TYPE = NON_HDL, ISVALID = (C_VMEM_INTERFACE == 0)
PARAMETER C_MPLB_PRIORITY = 3, DT = INTEGER, BUS = MPLB, RANGE = (0,1,2,3), ISVALID = (C_VMEM_INTERFACE == 0)
PARAMETER C_MPLB_P2P = 0, DT = INTEGER, BUS = MPLB, RANGE = (0,1), TYPE = NON_HDL, ISVALID = (C_VMEM_INTERFACE == 0)
PARAMETER C_MPLB_SUPPORT_BURSTS = 1, BUS = MPLB, ASSIGNMENT = CONSTANT, ISVALID = (C_VMEM_INTERFACE == 0)
## XMB generics
PARAMETER C_XMB_DATA_BUS_WIDTH = 64, DT = INTEGER, RANGE = (32, 64, 128), PERMIT = BASE_USER, ISVALID = (C_VMEM_INTERFACE == 1)
## AXI Master generics
PARAMETER C_M_AXI_SUPPORTS_THREADS = 0, DT = integer, BUS = M_AXI, ASSIGNMENT = CONSTANT, TYPE = NON_HDL, ISVALID = (C_VMEM_INTERFACE == 2)
PARAMETER C_M_AXI_THREAD_ID_WIDTH = 1, DT = integer, BUS = M_AXI, ASSIGNMENT = CONSTANT, ISVALID = (C_VMEM_INTERFACE == 2)
PARAMETER C_M_AXI_SUPPORTS_READ = 1, DT = integer, BUS = M_AXI, ASSIGNMENT = CONSTANT, TYPE = NON_HDL, ISVALID = (C_VMEM_INTERFACE == 2)
PARAMETER C_M_AXI_SUPPORTS_WRITE = 0, DT = integer, BUS = M_AXI, ASSIGNMENT = CONSTANT, TYPE = NON_HDL, ISVALID = (C_VMEM_INTERFACE == 2)
PARAMETER C_M_AXI_SUPPORTS_NARROW_BURST = 0, DT = integer, BUS = M_AXI, ASSIGNMENT = CONSTANT, TYPE = NON_HDL, ISVALID = (C_VMEM_INTERFACE == 2)
PARAMETER C_M_AXI_DATA_WIDTH = 64, DT = integer, RANGE = (32, 64, 128), BUS = M_AXI, ISVALID = (C_VMEM_INTERFACE == 2)
PARAMETER C_M_AXI_ADDR_WIDTH = 32, DT = integer, RANGE = (32), BUS = M_AXI, ASSIGNMENT = CONSTANT, ISVALID = (C_VMEM_INTERFACE == 2)
PARAMETER C_M_AXI_PROTOCOL = AXI4, DT = string, TYPE = NON_HDL, ASSIGNMENT = CONSTANT, BUS = M_AXI, ISVALID = (C_VMEM_INTERFACE == 2)
PARAMETER C_INTERCONNECT_M_AXI_ARB_PRIORITY = 0, DT = integer, BUS = M_AXI, RANGE = (0:15), TYPE = NON_HDL, ISVALID = (C_VMEM_INTERFACE == 2)
########## Registers ##########
PARAMETER C_REGS_INTERFACE = 0, DT = integer, RANGE = (0,1,2), VALUES = (0=OPB, 1=PLBv46, 2=AXI4-Lite), DESC = "Use OPB, SPLB or AXI4-Lite to access logiCVC registers"
PARAMETER C_READABLE_REGS = 1, DT = integer, RANGE = (0,1), DESC = "logiCVC registers read interface usage"
PARAMETER C_REG_BYTE_SWAP = 0, DT = INTEGER, RANGE = (0,1)
PARAMETER C_REGS_BASEADDR = 0xffffffff, DT = std_logic_vector, PAIR = C_REGS_HIGHADDR, ADDRESS = BASE, ADDR_TYPE = REGISTER, ASSIGNMENT = REQUIRE, BUS = SPLB:SOPB:S_AXI, MIN_SIZE = 0x8000
PARAMETER C_REGS_HIGHADDR = 0x00000000, DT = std_logic_vector, PAIR = C_REGS_BASEADDR, ADDRESS = HIGH, ADDR_TYPE = REGISTER, ASSIGNMENT = REQUIRE, BUS = SPLB:SOPB:S_AXI
## OPB generics
PARAMETER C_OPB_DWIDTH = 32, DT = integer, ISVALID = (C_REGS_INTERFACE == 0)
PARAMETER C_OPB_AWIDTH = 32, DT = integer, ISVALID = (C_REGS_INTERFACE == 0)
## PLB Slave generics
PARAMETER C_SPLB_AWIDTH = 32, DT = INTEGER, BUS = SPLB, ASSIGNMENT = CONSTANT, ISVALID = (C_REGS_INTERFACE == 1)
PARAMETER C_SPLB_DWIDTH = 32, DT = INTEGER, BUS = SPLB, ISVALID = (C_REGS_INTERFACE == 1)
PARAMETER C_SPLB_MID_WIDTH = 1, DT = INTEGER, BUS = SPLB, ISVALID = (C_REGS_INTERFACE == 1)
PARAMETER C_SPLB_NUM_MASTERS = 2, DT = INTEGER, BUS = SPLB, ISVALID = (C_REGS_INTERFACE == 1)
PARAMETER C_SPLB_NATIVE_DWIDTH = 32, DT = INTEGER, BUS = SPLB, ASSIGNMENT = CONSTANT, ISVALID = (C_REGS_INTERFACE == 1)
## AXI4-Lite Slave generics
PARAMETER C_S_AXI_ADDR_WIDTH = 32, DT = INTEGER, BUS = S_AXI, ASSIGNMENT = CONSTANT, ISVALID = (C_REGS_INTERFACE == 2)
PARAMETER C_S_AXI_DATA_WIDTH = 32, DT = INTEGER, BUS = S_AXI, ASSIGNMENT = CONSTANT, ISVALID = (C_REGS_INTERFACE == 2)
PARAMETER C_S_AXI_PROTOCOL = AXI4LITE, DT = STRING, BUS = S_AXI, TYPE = NON_HDL, ASSIGNMENT = CONSTANT, ISVALID = (C_REGS_INTERFACE == 2)
########## CVC generics ##########
PARAMETER C_PIXEL_DATA_WIDTH = 16, DT = INTEGER, RANGE = (12,15,16,18,24), VALUES = (12=12*2, 15=15, 16=16, 18=18, 24=24), PERMIT = BASE_USER, DESC = "Pixel Data Width"
PARAMETER C_USE_VCLK2 = 1, DT = INTEGER, ISVALID = (C_PIXEL_DATA_WIDTH == 12), RANGE = (0,1), PERMIT = BASE_USER, DESC = "Use vclk2 for DDR pixel data output"
PARAMETER C_ROW_STRIDE = 1024, DT = INTEGER, RANGE = (512, 1024, 2048), PERMIT = BASE_USER, DESC = "Row Stride in Number of Pixels"
PARAMETER C_XCOLOR = 0, DT = INTEGER, RANGE = (0,1), VALUES = (0=NO XCOLOR, 1=XCOLOR), PERMIT = BASE_USER, DESC = "XCOLOR function", ISVALID = (C_PIXEL_DATA_WIDTH == 18 || C_DISPLAY_INTERFACE == 4)
PARAMETER C_USE_SIZE_POSITION = 1, DT = INTEGER, RANGE = (0,1), DESC = "Use Layer Size and Layer Position"
PARAMETER C_DISPLAY_INTERFACE = 0, DT = INTEGER, RANGE = (0,1,2,3,4,5), VALUES = (0=Parallel, 1=ITU656, 2=LVDS 4bit, 3=Camera link 4bit, 4=LVDS 3bit, 5=DVI), DESC = "Display interface"
PARAMETER C_DISPLAY_COLOR_SPACE = 0, DT = INTEGER, RANGE = (0,1,2), VALUES = (0=RGB, 1=YCbCr 4:2:2, 2=YCbCr 4:4:4), DESC = "Display interface color space"
PARAMETER C_VCLK_PERIOD = 25000, DT = INTEGER, RANGE = (1000:52630), CLK_PORT = vclk, CLK_UNIT = PS, ISVALID = (C_DISPLAY_INTERFACE == 5)
PARAMETER C_LVDS_DATA_WIDTH = 4, DT = INTEGER, RANGE = (3,4), ASSIGNMENT = UPDATE, IPLEVEL_UPDATE_VALUE_PROC = iplevel_update_lvds_dwidth
## Multilayer generics
PARAMETER C_NUM_OF_LAYERS = 1, DT = integer, RANGE = (1,2,3,4,5)
PARAMETER C_LAYER_0_TYPE = 0, DT = integer, RANGE = (0,1), VALUES = (0=RGB, 1=YCbCr)
PARAMETER C_LAYER_1_TYPE = 0, DT = integer, RANGE = (0,1,2), VALUES = (0=RGB, 1=YCbCr, 2=Alpha), ISVALID = (C_NUM_OF_LAYERS > 1)
PARAMETER C_LAYER_2_TYPE = 0, DT = integer, RANGE = (0,1), VALUES = (0=RGB, 1=YCbCr), ISVALID = (C_NUM_OF_LAYERS > 2)
PARAMETER C_LAYER_3_TYPE = 0, DT = integer, RANGE = (0,1,2), VALUES = (0=RGB, 1=YCbCr, 2=Alpha), ISVALID = (C_NUM_OF_LAYERS > 3)
PARAMETER C_LAYER_4_TYPE = 0, DT = integer, RANGE = (0,1), VALUES = (0=RGB, 1=YCbCr), ISVALID = (C_NUM_OF_LAYERS > 4)
PARAMETER C_LAYER_0_DATA_WIDTH = 16, DT = integer, RANGE = (8,16,24)
PARAMETER C_LAYER_1_DATA_WIDTH = 16, DT = integer, RANGE = (8,16,24), ISVALID = (C_NUM_OF_LAYERS > 1)
PARAMETER C_LAYER_2_DATA_WIDTH = 16, DT = integer, RANGE = (8,16,24), ISVALID = (C_NUM_OF_LAYERS > 2)
PARAMETER C_LAYER_3_DATA_WIDTH = 16, DT = integer, RANGE = (8,16,24), ISVALID = (C_NUM_OF_LAYERS > 3)
PARAMETER C_LAYER_4_DATA_WIDTH = 16, DT = integer, RANGE = (8,16,24), ISVALID = (C_NUM_OF_LAYERS > 4)
PARAMETER C_LAYER_0_ALPHA_MODE = 0, DT = integer, RANGE = (0,1,2,3), VALUES = (0=Layer, 1=Pixel, 2=16bit CLUT, 3=24bit CLUT), ISVALID = (C_USE_E_PARALLEL_INPUT == 0 || (C_USE_E_PARALLEL_INPUT == 1 && C_E_LAYER != 0))
PARAMETER C_LAYER_1_ALPHA_MODE = 0, DT = integer, RANGE = (0,1,2,3), VALUES = (0=Layer, 1=Pixel, 2=16bit CLUT, 3=24bit CLUT), ISVALID = (((C_NUM_OF_LAYERS == 2 && C_USE_BACKGROUND == 0) || C_NUM_OF_LAYERS > 2) && (C_USE_E_PARALLEL_INPUT == 0 || (C_USE_E_PARALLEL_INPUT == 1 && C_E_LAYER != 1)))
PARAMETER C_LAYER_2_ALPHA_MODE = 0, DT = integer, RANGE = (0,1,2,3), VALUES = (0=Layer, 1=Pixel, 2=16bit CLUT, 3=24bit CLUT), ISVALID = (((C_NUM_OF_LAYERS == 3 && C_USE_BACKGROUND == 0) || C_NUM_OF_LAYERS > 3) && (C_USE_E_PARALLEL_INPUT == 0 || (C_USE_E_PARALLEL_INPUT == 1 && C_E_LAYER != 2)))
PARAMETER C_LAYER_3_ALPHA_MODE = 0, DT = integer, RANGE = (0,1,2,3), VALUES = (0=Layer, 1=Pixel, 2=16bit CLUT, 3=24bit CLUT), ISVALID = (((C_NUM_OF_LAYERS == 4 && C_USE_BACKGROUND == 0) || C_NUM_OF_LAYERS > 4) && (C_USE_E_PARALLEL_INPUT == 0 || (C_USE_E_PARALLEL_INPUT == 1 && C_E_LAYER != 3)))
PARAMETER C_LAYER_4_ALPHA_MODE = 0, DT = integer, RANGE = (0,1,2,3), VALUES = (0=Layer, 1=Pixel, 2=16bit CLUT, 3=24bit CLUT), ISVALID = ((C_NUM_OF_LAYERS == 5 && C_USE_BACKGROUND == 0) && (C_USE_E_PARALLEL_INPUT == 0 || (C_USE_E_PARALLEL_INPUT == 1 && C_E_LAYER != 4)))
PARAMETER C_USE_BACKGROUND = 0, DT = integer, RANGE = (0,1), ISVALID = (C_NUM_OF_LAYERS > 1), DESC = "Configure last layer as background"
PARAMETER C_USE_XTREME_DSP = 2, DT = INTEGER, RANGE = (0,1,2), VALUES = (0=no, 1=yes, 2=auto), DESC="Use DSP resources for blender"
PARAMETER C_USE_MULTIPLIER = 2, DT = INTEGER, RANGE = (0,1,2), VALUES = (0=lut, 1=block, 2=auto), DESC="Type of multiplier used in blender"
PARAMETER C_LAYER_0_OFFSET = 0, DT = natural, ISVALID = (C_USE_E_PARALLEL_INPUT == 0 || (C_USE_E_PARALLEL_INPUT == 1 && C_E_LAYER != 0))
PARAMETER C_LAYER_1_OFFSET = 2048, DT = natural, ISVALID = (((C_NUM_OF_LAYERS == 2 && C_USE_BACKGROUND == 0) || C_NUM_OF_LAYERS > 2) && (C_USE_E_PARALLEL_INPUT == 0 || (C_USE_E_PARALLEL_INPUT == 1 && C_E_LAYER != 1)))
PARAMETER C_LAYER_2_OFFSET = 4096, DT = natural, ISVALID = (((C_NUM_OF_LAYERS == 3 && C_USE_BACKGROUND == 0) || C_NUM_OF_LAYERS > 3) && (C_USE_E_PARALLEL_INPUT == 0 || (C_USE_E_PARALLEL_INPUT == 1 && C_E_LAYER != 2)))
PARAMETER C_LAYER_3_OFFSET = 6144, DT = natural, ISVALID = (((C_NUM_OF_LAYERS == 4 && C_USE_BACKGROUND == 0) || C_NUM_OF_LAYERS > 4) && (C_USE_E_PARALLEL_INPUT == 0 || (C_USE_E_PARALLEL_INPUT == 1 && C_E_LAYER != 3)))
PARAMETER C_LAYER_4_OFFSET = 8192, DT = natural, ISVALID = ((C_NUM_OF_LAYERS == 5 && C_USE_BACKGROUND == 0) && (C_USE_E_PARALLEL_INPUT == 0 || (C_USE_E_PARALLEL_INPUT == 1 && C_E_LAYER != 4)))
PARAMETER C_BUFFER_0_OFFSET = 1024, DT = natural, ISVALID = (C_USE_E_PARALLEL_INPUT == 0 || (C_USE_E_PARALLEL_INPUT == 1 && C_E_LAYER != 0))
PARAMETER C_BUFFER_1_OFFSET = 1024, DT = natural, ISVALID = (((C_NUM_OF_LAYERS == 2 && C_USE_BACKGROUND == 0) || C_NUM_OF_LAYERS > 2) && (C_USE_E_PARALLEL_INPUT == 0 || (C_USE_E_PARALLEL_INPUT == 1 && C_E_LAYER != 1)))
PARAMETER C_BUFFER_2_OFFSET = 1024, DT = natural, ISVALID = (((C_NUM_OF_LAYERS == 3 && C_USE_BACKGROUND == 0) || C_NUM_OF_LAYERS > 3) && (C_USE_E_PARALLEL_INPUT == 0 || (C_USE_E_PARALLEL_INPUT == 1 && C_E_LAYER != 2)))
PARAMETER C_BUFFER_3_OFFSET = 1024, DT = natural, ISVALID = (((C_NUM_OF_LAYERS == 4 && C_USE_BACKGROUND == 0) || C_NUM_OF_LAYERS > 4) && (C_USE_E_PARALLEL_INPUT == 0 || (C_USE_E_PARALLEL_INPUT == 1 && C_E_LAYER != 3)))
PARAMETER C_BUFFER_4_OFFSET = 1024, DT = natural, ISVALID = ((C_NUM_OF_LAYERS == 5 && C_USE_BACKGROUND == 0) && (C_USE_E_PARALLEL_INPUT == 0 || (C_USE_E_PARALLEL_INPUT == 1 && C_E_LAYER != 4)))
## Extern parallel input generics
PARAMETER C_USE_E_PARALLEL_INPUT = 0, DT = integer, RANGE = (0,1), ISVALID = (C_NUM_OF_LAYERS > 1), DESC = "Syncronize logiCVC to external parallel input and use data as one layer"
PARAMETER C_USE_E_VCLK_BUFGMUX = 1, DT = integer, RANGE = (0,1), ISVALID = (C_USE_E_PARALLEL_INPUT == 1), DESC = "Use BUFGMUX for clock switching for external parallel"
PARAMETER C_E_LAYER = 0, DT = integer, RANGE = (0,1,2,3,4), ISVALID = (C_USE_E_PARALLEL_INPUT == 1), DESC = "Use extern parallel input as which layer"
PARAMETER C_E_DATA_WIDTH = 24, DT = integer, RANGE = (8,16,24), ISVALID = (C_USE_E_PARALLEL_INPUT == 1), DESC = "Extern parallel input data width"


## XYLON Memory Port
PORT mem_req = mem_req, DIR = O, BUS = XMB
PORT mem_wr  = mem_wr, DIR = O, BUS = XMB
PORT mem_ack = mem_ack, DIR = I, BUS = XMB
PORT mem_addr = mem_addr, DIR = O, VEC = [31:0], BUS = XMB
PORT mem_data = mem_data_wr, DIR = O, VEC = [C_XMB_DATA_BUS_WIDTH-1:0], BUS = XMB
PORT mem_data_be = mem_data_be, DIR = O, VEC = [C_XMB_DATA_BUS_WIDTH/8-1:0], BUS = XMB
PORT mem_wrack = mem_wrack, DIR = I, BUS = XMB
PORT mem_burst = mem_burst, DIR = O, VEC = [C_MEM_BURST-1:0], BUS = XMB
PORT mem_data_in = mem_data_rd, DIR = I, VEC = [C_XMB_DATA_BUS_WIDTH-1:0], BUS = XMB
PORT mem_data_valid = mem_data_valid, DIR = I, BUS = XMB
## PLB Master Ports
PORT MPLB_Rst = MPLB_Rst, DIR = I, BUS = MPLB
PORT M_Request = M_Request, DIR = O, BUS = MPLB
PORT M_Abort = M_Abort, DIR = O, BUS = MPLB
PORT M_Priority = M_Priority, DIR = O, VEC = [0:1], BUS = MPLB
PORT M_Buslock = M_BusLock, DIR = O, BUS = MPLB
PORT M_LockErr = M_LockErr, DIR = O, BUS = MPLB
PORT M_TAttribute = M_TAttribute, DIR = O, VEC = [0:15], BUS = MPLB
PORT M_Type = M_Type, DIR = O, VEC = [0:2], BUS = MPLB
PORT M_BE = M_BE, DIR = O, VEC = [0:((C_MPLB_DWIDTH/8)-1)], BUS = MPLB
PORT M_RNW = M_RNW, DIR = O, BUS = MPLB
PORT M_UABus = M_UABus, DIR = O, VEC = [0:(C_MPLB_AWIDTH-1)], BUS = MPLB
PORT M_ABus = M_ABus, DIR = O, VEC = [0:(C_MPLB_AWIDTH-1)], BUS = MPLB
PORT M_MSize = M_MSize, DIR = O, VEC = [0:1], BUS = MPLB
PORT M_size = M_size, DIR = O, VEC = [0:3], BUS = MPLB
PORT M_WrBurst = M_WrBurst, DIR = O, BUS = MPLB
PORT M_RdBurst = M_RdBurst, DIR = O, BUS = MPLB
PORT M_WrDBus = M_WrDBus, DIR = O, VEC = [0:(C_MPLB_DWIDTH-1)], BUS = MPLB
PORT PLB_MAddrAck = PLB_MAddrAck, DIR = I, BUS = MPLB
PORT PLB_MSSize = PLB_MSSize, DIR = I, VEC = [0:1], BUS = MPLB
PORT PLB_MRearbitrate = PLB_MRearbitrate, DIR = I, BUS = MPLB
PORT PLB_MTimeout = PLB_MTimeout, DIR = I, BUS = MPLB
PORT PLB_MWrDAck = PLB_MWrDAck, DIR = I, BUS = MPLB
PORT PLB_MWrBTerm = PLB_MWrBTerm, DIR = I, BUS = MPLB
PORT PLB_MRdDBus = PLB_MRdDBus, DIR = I, VEC = [0:(C_MPLB_DWIDTH-1)], BUS = MPLB
PORT PLB_MRdWdAddr = PLB_MRdWdAddr, DIR = I, VEC = [0:3], BUS = MPLB
PORT PLB_MRdDAck = PLB_MRdDAck, DIR = I, BUS = MPLB
PORT PLB_MRdBTerm = PLB_MRdBTerm, DIR = I, BUS = MPLB
PORT PLB_MBusy = PLB_MBusy, DIR = I, BUS = MPLB
PORT PLB_MRdErr = PLB_MRdErr, DIR = I, BUS = MPLB
PORT PLB_MWrErr = PLB_MWrErr, DIR = I, BUS = MPLB
PORT PLB_MIRQ = PLB_MIRQ, DIR = I, BUS = MPLB
## AXI Master Ports
PORT M_AXI_ARESETN = ARESETN, DIR = I, SIGIS = RST, BUS = M_AXI
PORT M_AXI_AWID = AWID, DIR = O, VEC = [(C_M_AXI_THREAD_ID_WIDTH-1):0], ENDIAN = LITTLE, BUS = M_AXI
PORT M_AXI_AWADDR = AWADDR, DIR = O, VEC = [(C_M_AXI_ADDR_WIDTH-1):0], ENDIAN = LITTLE, BUS = M_AXI
PORT M_AXI_AWLEN = AWLEN, DIR = O, VEC = [7:0], BUS = M_AXI
PORT M_AXI_AWSIZE = AWSIZE, DIR = O, VEC = [2:0], BUS = M_AXI
PORT M_AXI_AWBURST = AWBURST, DIR = O, VEC = [1:0], BUS = M_AXI
PORT M_AXI_AWLOCK = AWLOCK, DIR = O, VEC = [1:0], BUS = M_AXI
PORT M_AXI_AWCACHE = AWCACHE, DIR = O, VEC = [3:0], BUS = M_AXI
PORT M_AXI_AWPROT = AWPROT, DIR = O, VEC = [2:0], BUS = M_AXI
PORT M_AXI_AWQOS = AWQOS, DIR = O, VEC = [3:0], BUS = M_AXI
PORT M_AXI_AWVALID = AWVALID, DIR = O, BUS = M_AXI
PORT M_AXI_AWREADY = AWREADY, DIR = I, BUS = M_AXI
PORT M_AXI_WDATA = WDATA, DIR = O, VEC = [(C_M_AXI_DATA_WIDTH-1):0], ENDIAN = LITTLE, BUS = M_AXI
PORT M_AXI_WSTRB = WSTRB, DIR = O, VEC = [((C_M_AXI_DATA_WIDTH/8)-1):0], ENDIAN = LITTLE, BUS = M_AXI
PORT M_AXI_WLAST = WLAST, DIR = O, BUS = M_AXI
PORT M_AXI_WVALID = WVALID, DIR = O, BUS = M_AXI
PORT M_AXI_WREADY = WREADY, DIR = I, BUS = M_AXI
PORT M_AXI_BID = BID, DIR = I, VEC = [(C_M_AXI_THREAD_ID_WIDTH-1):0], ENDIAN = LITTLE, BUS = M_AXI
PORT M_AXI_BRESP = BRESP, DIR = I, VEC = [1:0], BUS = M_AXI
PORT M_AXI_BVALID = BVALID, DIR = I, BUS = M_AXI
PORT M_AXI_BREADY = BREADY, DIR = O, BUS = M_AXI
PORT M_AXI_ARID = ARID, DIR = O, VEC = [(C_M_AXI_THREAD_ID_WIDTH-1):0], ENDIAN = LITTLE, BUS = M_AXI
PORT M_AXI_ARADDR = ARADDR, DIR = O, VEC = [(C_M_AXI_ADDR_WIDTH-1):0], ENDIAN = LITTLE, BUS = M_AXI
PORT M_AXI_ARLEN = ARLEN, DIR = O, VEC = [7:0], BUS = M_AXI
PORT M_AXI_ARSIZE = ARSIZE, DIR = O, VEC = [2:0], BUS = M_AXI
PORT M_AXI_ARBURST = ARBURST, DIR = O, VEC = [1:0], BUS = M_AXI
PORT M_AXI_ARLOCK = ARLOCK, DIR = O, VEC = [1:0], BUS = M_AXI
PORT M_AXI_ARCACHE = ARCACHE, DIR = O, VEC = [3:0], BUS = M_AXI
PORT M_AXI_ARPROT = ARPROT, DIR = O, VEC = [2:0], BUS = M_AXI
PORT M_AXI_ARQOS = ARQOS, DIR = O, VEC = [3:0], BUS = M_AXI
PORT M_AXI_ARVALID = ARVALID, DIR = O, BUS = M_AXI
PORT M_AXI_ARREADY = ARREADY, DIR = I, BUS = M_AXI
PORT M_AXI_RID = RID, DIR = I, VEC = [(C_M_AXI_THREAD_ID_WIDTH-1):0], ENDIAN = LITTLE, BUS = M_AXI
PORT M_AXI_RDATA = RDATA, DIR = I, VEC = [(C_M_AXI_DATA_WIDTH-1):0], ENDIAN = LITTLE, BUS = M_AXI
PORT M_AXI_RRESP = RRESP, DIR = I, VEC = [1:0], BUS = M_AXI
PORT M_AXI_RLAST = RLAST, DIR = I, BUS = M_AXI
PORT M_AXI_RVALID = RVALID, DIR = I, BUS = M_AXI
PORT M_AXI_RREADY = RREADY, DIR = O, BUS = M_AXI
## OPB Ports
PORT OPB_Clk = "", DIR = IN, SIGIS = CLK, BUS = SOPB
PORT OPB_Rst = OPB_Rst, DIR = IN, BUS = SOPB
PORT OPB_ABus = OPB_ABus, DIR = IN, VEC = [0:C_OPB_AWIDTH-1], BUS = SOPB
PORT OPB_BE = OPB_BE, DIR = IN, VEC = [0:C_OPB_DWIDTH/8-1], BUS = SOPB
PORT OPB_RNW = OPB_RNW, DIR = IN, BUS = SOPB
PORT OPB_select = OPB_select, DIR = IN, BUS = SOPB
PORT OPB_seqAddr = OPB_seqAddr, DIR = IN, BUS = SOPB
PORT OPB_DBus = OPB_DBus, DIR = IN, VEC = [0:C_OPB_DWIDTH-1], BUS = SOPB
PORT Sl_DBus = Sl_DBus, DIR = OUT, VEC = [0:C_OPB_DWIDTH-1], BUS = SOPB
PORT Sl_errAck = Sl_errAck, DIR = OUT, BUS = SOPB
PORT Sl_retry = Sl_retry, DIR = OUT, BUS = SOPB
PORT Sl_toutSup = Sl_toutSup, DIR = OUT, BUS = SOPB
PORT Sl_xferAck = Sl_xferAck, DIR = OUT, BUS = SOPB
## PLB Slave interface
PORT SPLB_Clk = "", DIR = I, SIGIS = Clk, BUS = SPLB
PORT SPLB_Rst = SPLB_Rst, DIR = I, SIGIS = Rst, BUS = SPLB
PORT PLB_ABus = PLB_ABus, DIR = I, VEC = [0:31], BUS = SPLB
PORT PLB_UABus = PLB_UABus, DIR = I, VEC = [0:31], BUS = SPLB
PORT PLB_PAValid = PLB_PAValid, DIR = I, BUS = SPLB
PORT PLB_SAValid = PLB_SAValid, DIR = I, BUS = SPLB
PORT PLB_rdPrim = PLB_rdPrim, DIR = I, BUS = SPLB
PORT PLB_wrPrim = PLB_wrPrim, DIR = I, BUS = SPLB
PORT PLB_masterID = PLB_masterID, DIR = I, VEC = [0:(C_SPLB_MID_WIDTH-1)], BUS = SPLB
PORT PLB_abort = PLB_abort, DIR = I, BUS = SPLB
PORT PLB_busLock = PLB_busLock, DIR = I, BUS = SPLB
PORT PLB_RNW = PLB_RNW, DIR = I, BUS = SPLB
PORT PLB_BE = PLB_BE, DIR = I, VEC = [0:((C_SPLB_DWIDTH/8)-1)], BUS = SPLB
PORT PLB_MSize = PLB_MSize, DIR = I, VEC = [0:1], BUS = SPLB
PORT PLB_size = PLB_size, DIR = I, VEC = [0:3], BUS = SPLB
PORT PLB_type = PLB_type, DIR = I, VEC = [0:2], BUS = SPLB
PORT PLB_lockErr = PLB_lockErr, DIR = I, BUS = SPLB
PORT PLB_wrDBus = PLB_wrDBus, DIR = I, VEC = [0:(C_SPLB_DWIDTH-1)], BUS = SPLB
PORT PLB_wrBurst = PLB_wrBurst, DIR = I, BUS = SPLB
PORT PLB_rdBurst = PLB_rdBurst, DIR = I, BUS = SPLB
PORT PLB_wrPendReq = PLB_wrPendReq, DIR = I, BUS = SPLB
PORT PLB_rdPendReq = PLB_rdPendReq, DIR = I, BUS = SPLB
PORT PLB_wrPendPri = PLB_wrPendPri, DIR = I, VEC = [0:1], BUS = SPLB
PORT PLB_rdPendPri = PLB_rdPendPri, DIR = I, VEC = [0:1], BUS = SPLB
PORT PLB_reqPri = PLB_reqPri, DIR = I, VEC = [0:1], BUS = SPLB
PORT PLB_TAttribute = PLB_TAttribute, DIR = I, VEC = [0:15], BUS = SPLB
PORT Sl_addrAck = Sl_addrAck, DIR = O, BUS = SPLB
PORT Sl_SSize = Sl_SSize, DIR = O, VEC = [0:1], BUS = SPLB
PORT Sl_wait = Sl_wait, DIR = O, BUS = SPLB
PORT Sl_rearbitrate = Sl_rearbitrate, DIR = O, BUS = SPLB
PORT Sl_wrDAck = Sl_wrDAck, DIR = O, BUS = SPLB
PORT Sl_wrComp = Sl_wrComp, DIR = O, BUS = SPLB
PORT Sl_wrBTerm = Sl_wrBTerm, DIR = O, BUS = SPLB
PORT Sl_rdDBus = Sl_rdDBus, DIR = O, VEC = [0:(C_SPLB_DWIDTH-1)], BUS = SPLB
PORT Sl_rdWdAddr = Sl_rdWdAddr, DIR = O, VEC = [0:3], BUS = SPLB
PORT Sl_rdDAck = Sl_rdDAck, DIR = O, BUS = SPLB
PORT Sl_rdComp = Sl_rdComp, DIR = O, BUS = SPLB
PORT Sl_rdBTerm = Sl_rdBTerm, DIR = O, BUS = SPLB
PORT Sl_MBusy = Sl_MBusy, DIR = O, VEC = [0:(C_SPLB_NUM_MASTERS-1)], BUS = SPLB
PORT Sl_MWrErr = Sl_MWrErr, DIR = O, VEC = [0:(C_SPLB_NUM_MASTERS-1)], BUS = SPLB
PORT Sl_MRdErr = Sl_MRdErr, DIR = O, VEC = [0:(C_SPLB_NUM_MASTERS-1)], BUS = SPLB
PORT Sl_MIRQ = Sl_MIRQ, DIR = O, VEC = [0:(C_SPLB_NUM_MASTERS-1)], BUS = SPLB
## AXI4-Lite Slave interface
PORT S_AXI_ACLK = "", DIR = I, SIGIS = CLK, BUS = S_AXI
PORT S_AXI_ARESETN = ARESETN, DIR = I, SIGIS = RST, BUS = S_AXI
PORT S_AXI_AWADDR = AWADDR, DIR = I, VEC = [(C_S_AXI_ADDR_WIDTH-1):0], ENDIAN = LITTLE, BUS = S_AXI
PORT S_AXI_AWVALID = AWVALID, DIR = I, BUS = S_AXI
PORT S_AXI_AWREADY = AWREADY, DIR = O, BUS = S_AXI
PORT S_AXI_WDATA = WDATA, DIR = I, VEC = [(C_S_AXI_DATA_WIDTH-1):0], ENDIAN = LITTLE, BUS = S_AXI
PORT S_AXI_WSTRB = WSTRB, DIR = I, VEC = [((C_S_AXI_DATA_WIDTH/8)-1):0], ENDIAN = LITTLE, BUS = S_AXI
PORT S_AXI_WVALID = WVALID, DIR = I, BUS = S_AXI
PORT S_AXI_WREADY = WREADY, DIR = O, BUS = S_AXI
PORT S_AXI_BRESP = BRESP, DIR = O, VEC = [1:0], BUS = S_AXI
PORT S_AXI_BVALID = BVALID, DIR = O, BUS = S_AXI
PORT S_AXI_BREADY = BREADY, DIR = I, BUS = S_AXI
PORT S_AXI_ARADDR = ARADDR, DIR = I, VEC = [(C_S_AXI_ADDR_WIDTH-1):0], ENDIAN = LITTLE, BUS = S_AXI
PORT S_AXI_ARVALID = ARVALID, DIR = I, BUS = S_AXI
PORT S_AXI_ARREADY = ARREADY, DIR = O, BUS = S_AXI
PORT S_AXI_RDATA = RDATA, DIR = O, VEC = [(C_S_AXI_DATA_WIDTH-1):0], ENDIAN = LITTLE, BUS = S_AXI
PORT S_AXI_RRESP = RRESP, DIR = O, VEC = [1:0], BUS = S_AXI
PORT S_AXI_RVALID = RVALID, DIR = O, BUS = S_AXI
PORT S_AXI_RREADY = RREADY, DIR = I, BUS = S_AXI

## CVC Ports
PORT rst = "", DIR = I, SIGIS = RST, ASSIGNMENT = REQUIRE, DESC = "Global logiCVC reset"
PORT mclk = "", DIR = I, SIGIS = CLK, BUS = MPLB:XMB:M_AXI, ASSIGNMENT = REQUIRE, DESC = "Memory clock, either PLB, XMB or AXI"
PORT vclk = "", DIR = I, SIGIS = CLK, PERMIT = BASE_USER, ASSIGNMENT = REQUIRE, DESC = "Video clock"
PORT vclk2 = "", DIR = I, SIGIS = CLK, PERMIT = BASE_USER, ASSIGNMENT = REQUIRE, ISVALID = (C_PIXEL_DATA_WIDTH == 12 && C_USE_VCLK2 == 1), DESC = "Video clock x2"
PORT itu_clk_in = "", DIR = I, SIGIS = CLK, PERMIT = BASE_USER, ISVALID = (C_DISPLAY_INTERFACE == 1), DESC = "ITU656 clock. It has to be two times vclk, i.e. 27 MHZ, and synchronous to vclk"
PORT pix_clk = "", DIR = IO, THREE_STATE=TRUE, TRI_I = pix_clk_i, TRI_O = pix_clk_o, TRI_T = pix_clk_t, PERMIT = BASE_USER, DESC = "Pixel clock"
PORT pix_clk_i = "", DIR = I, PERMIT = BASE_USER, DESC = "Pixel clock input"
PORT pix_clk_o = "", DIR = O, PERMIT = BASE_USER, DESC = "Pixel clock output"
PORT pix_clk_t = "", DIR = O, PERMIT = BASE_USER, DESC = "Pixel clock enable"
PORT pix_clk_n = "", DIR = IO, THREE_STATE=TRUE, TRI_I = pix_clk_n_i, TRI_O = pix_clk_n_o, TRI_T = pix_clk_n_t, PERMIT = BASE_USER, DESC = "Pixel clock inverted"
PORT pix_clk_n_i = "", DIR = I, PERMIT = BASE_USER, DESC = "Pixel clock inverted input"
PORT pix_clk_n_o = "", DIR = O, PERMIT = BASE_USER, DESC = "Pixel clock inverted output"
PORT pix_clk_n_t = "", DIR = O, PERMIT = BASE_USER, DESC = "Pixel clock inverted enable"
PORT d_pix = "", DIR = IO, ENABLE=SINGLE, THREE_STATE=TRUE, TRI_I = d_pix_i, TRI_O = d_pix_o, TRI_T = d_pix_t, VEC = [C_PIXEL_DATA_WIDTH-1:0], PERMIT = BASE_USER, DESC = "Pixel data bus"
PORT d_pix_i = "", DIR = I, VEC = [C_PIXEL_DATA_WIDTH-1:0], ENDIAN=LITTLE, PERMIT = BASE_USER, DESC = "Pixel data bus input"
PORT d_pix_o = "", DIR = O, VEC = [C_PIXEL_DATA_WIDTH-1:0], ENDIAN=LITTLE, PERMIT = BASE_USER, DESC = "Pixel data bus output"
PORT d_pix_t = "", DIR = O, PERMIT = BASE_USER, DESC = "Pixel data bus enable"
PORT hsync = "", DIR = IO, THREE_STATE=TRUE, TRI_I = hsync_i, TRI_O = hsync_o, TRI_T = hsync_t, PERMIT = BASE_USER, DESC = "Hsync"
PORT hsync_i = "", DIR = I, PERMIT = BASE_USER, DESC = "Hsync input"
PORT hsync_o = "", DIR = O, PERMIT = BASE_USER, DESC = "Hsync output"
PORT hsync_t = "", DIR = O, PERMIT = BASE_USER, DESC = "Hsync enable"
PORT vsync = "", DIR = IO, THREE_STATE=TRUE, TRI_I = vsync_i, TRI_O = vsync_o, TRI_T = vsync_t, PERMIT = BASE_USER, DESC = "Vsync"
PORT vsync_i = "", DIR = I, PERMIT = BASE_USER, DESC = "Vsync input"
PORT vsync_o = "", DIR = O, PERMIT = BASE_USER, DESC = "Vsync output"
PORT vsync_t = "", DIR = O, PERMIT = BASE_USER, DESC = "Vsync enable"
PORT blank = "", DIR = IO, THREE_STATE=TRUE, TRI_I = blank_i, TRI_O = blank_o, TRI_T = blank_t, PERMIT = BASE_USER, DESC = "Blank/Enable"
PORT blank_i = "", DIR = I, PERMIT = BASE_USER, DESC = "Blank/Enable input"
PORT blank_o = "", DIR = O, PERMIT = BASE_USER, DESC = "Blank/Enable output"
PORT blank_t = "", DIR = O, PERMIT = BASE_USER, DESC = "Blank/Enable enable"
PORT itu656_clk_o = "", DIR = O, SIGIS = CLK, PERMIT = BASE_USER, ISVALID = (C_DISPLAY_INTERFACE == 1), DESC = "ITU656 clock output"
PORT itu656_data_o = "", DIR = O, VEC = [7:0], ENDIAN=LITTLE, PERMIT = BASE_USER, ISVALID = (C_DISPLAY_INTERFACE == 1), DESC = "ITU656 data output"
PORT lvds_clk = "", DIR = I, PERMIT = BASE_USER, ISVALID = (C_DISPLAY_INTERFACE == 2 || C_DISPLAY_INTERFACE == 3 || C_DISPLAY_INTERFACE == 4), DESC = "LVDS clock input"
PORT lvds_clkn = "", DIR = I, PERMIT = BASE_USER, ISVALID = (C_DISPLAY_INTERFACE == 2 || C_DISPLAY_INTERFACE == 3 || C_DISPLAY_INTERFACE == 4), DESC = "LVDS clock input inv"
PORT lvds_data_out_p = "", DIR = O, VEC = [C_LVDS_DATA_WIDTH-1:0], ENDIAN=LITTLE, PERMIT = BASE_USER, ISVALID = (C_DISPLAY_INTERFACE == 2 || C_DISPLAY_INTERFACE == 3 || C_DISPLAY_INTERFACE == 4), DESC = "LVDS data output pos"
PORT lvds_data_out_n = "", DIR = O, VEC = [C_LVDS_DATA_WIDTH-1:0], ENDIAN=LITTLE, PERMIT = BASE_USER, ISVALID = (C_DISPLAY_INTERFACE == 2 || C_DISPLAY_INTERFACE == 3 || C_DISPLAY_INTERFACE == 4), DESC = "LVDS data output neg"
PORT lvds_clk_out_p = "", DIR = O, PERMIT = BASE_USER, ISVALID = (C_DISPLAY_INTERFACE == 2 || C_DISPLAY_INTERFACE == 3 || C_DISPLAY_INTERFACE == 4), DESC = "LVDS clock output pos"
PORT lvds_clk_out_n = "", DIR = O, PERMIT = BASE_USER, ISVALID = (C_DISPLAY_INTERFACE == 2 || C_DISPLAY_INTERFACE == 3 || C_DISPLAY_INTERFACE == 4), DESC = "LVDS clock output neg"
PORT pllvclk_locked = "", DIR = I, PERMIT = BASE_USER, DESC = "PLL_BASE LOCKED signal used in spartan6"
PORT dvi_clk_p = "", DIR = O, PERMIT = BASE_USER, ISVALID = (C_DISPLAY_INTERFACE == 5), DESC = "DVI clock output pos"
PORT dvi_clk_n = "", DIR = O, PERMIT = BASE_USER, ISVALID = (C_DISPLAY_INTERFACE == 5), DESC = "DVI clock output neg"
PORT dvi_data_p = "", DIR = O, VEC = [2:0], ENDIAN=LITTLE, PERMIT = BASE_USER, ISVALID = (C_DISPLAY_INTERFACE == 5), DESC = "DVI data output pos"
PORT dvi_data_n = "", DIR = O, VEC = [2:0], ENDIAN=LITTLE, PERMIT = BASE_USER, ISVALID = (C_DISPLAY_INTERFACE == 5), DESC = "DVI data output neg"
PORT e_vclk = "", DIR = I, PERMIT = BASE_USER, DESC = "External video clock", ISVALID = (C_USE_E_PARALLEL_INPUT == 1)
PORT e_vsync = "", DIR = I, PERMIT = BASE_USER, DESC = "External vsync input", ISVALID = (C_USE_E_PARALLEL_INPUT == 1)
PORT e_hsync = "", DIR = I, PERMIT = BASE_USER, DESC = "External hsync input", ISVALID = (C_USE_E_PARALLEL_INPUT == 1)
PORT e_blank = "", DIR = I, PERMIT = BASE_USER, DESC = "External blank input", ISVALID = (C_USE_E_PARALLEL_INPUT == 1)
PORT e_data = "", DIR = I, VEC = [C_E_DATA_WIDTH-1:0], ENDIAN=LITTLE, PERMIT = BASE_USER, DESC = "External parallel data input", ISVALID = (C_USE_E_PARALLEL_INPUT == 1)
PORT e_video_present = "", DIR = I, PERMIT = BASE_USER, DESC = "External video present"
PORT e_curr_vbuff = "", DIR = I, VEC = [C_NUM_OF_LAYERS*2-1:0], ENDIAN=LITTLE, PERMIT = BASE_USER, DESC = "Current external stream video buffer"
PORT e_next_vbuff = "", DIR = O, VEC = [C_NUM_OF_LAYERS*2-1:0], ENDIAN=LITTLE, PERMIT = BASE_USER, DESC = "Next external stream video buffer to write to"
PORT e_sw_vbuff = "", DIR = I, VEC = [C_NUM_OF_LAYERS-1:0], ENDIAN=LITTLE, PERMIT = BASE_USER, DESC = "Switch CVC video buffers from external source"
PORT e_sw_grant = "", DIR = O, VEC = [C_NUM_OF_LAYERS-1:0], ENDIAN=LITTLE, PERMIT = BASE_USER, DESC = "CVC video buffers switch request granted"
PORT vcdivsel = "", DIR = O, VEC = [1:0], ENDIAN=LITTLE, PERMIT = BASE_USER, DESC = "vclk div select bits"
PORT vclksel = "", DIR = O, VEC = [2:0], ENDIAN=LITTLE, PERMIT = BASE_USER, DESC = "vclk select bits"
PORT en_vdd = "", DIR = O, PERMIT = BASE_USER, DESC = "Enable Vdd"
PORT en_blight = "", DIR = O, PERMIT = BASE_USER, DESC = "Enable backlight"
PORT v_en = "", DIR = O, PERMIT = BASE_USER, DESC = "Enable outputs"
PORT en_vee = "", DIR = O, PERMIT = BASE_USER, DESC = "Enable Vee"
PORT interrupt = "", DIR = O, SIGIS = INTERRUPT, SENSITIVITY = LEVEL_HIGH, PERMIT = BASE_USER, DESC = "CVC Interrupt siganl"
END
